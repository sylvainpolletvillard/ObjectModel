<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="description" content="ObjectModel : Runtime Type Checking and Data Model Definition for JavaScript">
	<meta name="author" content="Sylvain Pollet-Villard">

	<title>Object Model</title>

	<link rel="stylesheet" href="site/style/main.css"/>
	<link rel="stylesheet" href='http://fonts.googleapis.com/css?family=Raleway:300|Roboto:400,900'>
	<script src="site/lib/jquery-2.1.0.min.js"></script>

	<!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
	<!--[if lt IE 9]>
	<script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
	<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
	<![endif]-->
</head>

<body>
<button id="menu-button" class="lines-button arrow arrow-left" type="button" role="button" aria-label="Toggle Navigation">
	<span class="lines"></span>
</button>

<nav id="menu">
	<a class="title download-link" href="#download">
		<h2>Download</h2>
	</a>
	<hr>
	<a class="title github-link" href="https://github.com/sylvainpolletvillard/ObjectModel">
		<h2>View on Github</h2>
	</a>
	<hr>
	<div>
		<a href="#introduction" class="title">Introduction</a>
		<ul>
			<li><a href="#introduction">What is it</a></li>
			<li><a href="#features">Features</a></li>
			<li><a href="#browser-support">Browser support</a></li>
		</ul>
	</div>
	<hr>
	<div>
		<a href="#doc-object-model" class="title">Documentation</a>
		<ul>
			<li><a href="#doc-basic-model">Basic models</a></li>
			<li><a href="#doc-object-model">Object models</a></li>
			<li><a href="#doc-optional-properties">Optional properties</a></li>
			<li><a href="#doc-multiple-types">Multiple types</a></li>
			<li><a href="#doc-value-checking">Value checking and enumerations</a></li>
			<li><a href="#doc-null-safe">Null-safe object traversal</a></li>
			<li><a href="#doc-default-values">Default values</a></li>
			<li><a href="#doc-composition">Composition</a></li>
			<li><a href="#doc-extensions">Inheritance by extensions</a></li>
			<li><a href="#doc-assertions">Assertions for custom tests</a></li>
			<li><a href="#doc-private-and-constants">Private and constant properties</a></li>
			<li><a href="#doc-array-model">Array models</a></li>
			<li><a href="#doc-function-model">Function models</a></li>
			<li><a href="#api">Full API</a></li>
			<li><a href="#common-questions">Common questions</a></li>
		</ul>
	</div>
	<hr>
	<p class="footer">Â© 2015 syllab.fr</p>
</nav>

<div id="page">

	<section id="introduction">
		<header class="header">
			<h1>Object Model</h1>
			<hr>
			<p class="description">Model Definition and Runtime Type Checking for JavaScript</p>
		</header>

		<div class="panels two">
			<div class="panel">
				<span class="legend">Define typed models</span>
            <pre><code class="language-javascript">
   var User = new Model({
      name: String,
      female: Boolean,
      birth: Date
   });</code></pre>
			</div>
			<div class="panel">
				<span class="legend left">Validate at runtime</span>
            <pre><code class="language-javascript">
   var joe = new User({
      name: "Joe",
      female: false,
      birth: 1986
   });</code>
<code class="language-none exception">TypeError: expecting birth to be Date, got Number 1986</code></pre>
			</div>
		</div>

		<h2 id="what-is-it">What is this library ?</h2>
		<p>A recurring criticism of JavaScript is that it is a weakly typed language. New typed languages that compile to JavaScript have been invented like TypeScript from Microsoft. We also have static type checking tools like Flow from Facebook. This library is about dynamic type checking: it aims to get this type validation at runtime without requiring a new language or a compilation step.</p>
		<p>Validate at runtime allows you to define more specific tests that can change depending on your application state. You can also control unpredictable data sources like external JS dependencies or JSON data from web services .</p>

		<h2 id="features">What's inside the box ?</h2>
		<p>Many features, hopefully neither too much nor too little:</p>
		<ul>
			<li>Advanced model definition trying to reconcile prototypes and classes</li>
			<li>Typed object properties, typed arrays, typed functions</li>
			<li>Validation at instancing and future assignments</li>
			<li>Union types, enumerations and custom assertions</li>
			<li>Optional properties and default values</li>
			<li>Null-safe object traversal</li>
			<li>Easy inheritance and model extensions</li>
			<li>Constants and private properties based on name conventions</li>
			<li>Explicit error messages</li>
			<li>all in 6.1 kB minified (1.3 kB gzipped)</li>
		</ul>

		<h2 id="browser-support">Which browsers are supported ?</h2>
		<p>This library is <a href="test">unit tested</a> with latest versions of Chrome, Firefox and Internet Explorer. It should work on any browser implementing ECMAScript 5 specifications.</p>
	</section>

	<hr>

	<section id="download">
		<h2>Download</h2>
		<h3>Current version: v0.7.0</h3>
		<ul>
			<li><a href="dist/object-model.min.js">object-model.min.js</a> minified file (6.1 kB)</li>
			<li><a href="dist/object-model-0.7.0.zip">object-model-0.7.0.zip</a> source files</li>
		</ul>
		<details>
			<summary>Changelog</summary>
			<dl>
				<dt>v0.7</dt>
				<dd>API redesign to get a single namespace</dd>
				<dd>UMD version</dd>
				<dd>added model.assert</dd>
				<dd>removed arrayModel.min/max</dd>
				<dd>some performance improvements</dd>
				<dt>v0.6</dt>
				<dd>corrected models prototypal chain</dd>
				<dd>models prototype is used to store default values and methods</dd>
				<dd>automatic instanciation of Function models on object model properties</dd>
				<dt>v0.5</dt>
				<dd>constants and private properties by name convention</dd>
				<dd>unit tests</dd>
				<dt>v0.4</dt>
				<dd>Model.defaults, Model.Function.defaults</dd>
				<dd>Model.extend, Model.Array.extend</dd>
				<dd>Model.isValidModelFor</dd>
				<dt>v0.3</dt>
				<dd>Model.Function</dd>
				<dd>arguments and return value validation</dd>
				<dt>v0.2</dt>
				<dd>Model.Array</dd>
				<dd>Optional & mandatory parameters</dd>
				<dd>Multi-types parameters</dd>
				<dt>v0.1</dt>
				<dd>basic object Model</dd>
				<dd>null-safe traversing</dd>
				<dd>validation by constructor or equality</dd>
			</dl>
		</details>
		<details>
			<summary>Future versions</summary>
			<p>Possible changes under consideration:</p>
			<ul>
				<li>API changes based on feedback</li>
				<li>JSDoc parsing to automatic model definition</li>
			</ul>
		</details>

		<h3>GitHub repository</h3>
		<p>You can report bugs and contribute to the project on the <a href="https://github.com/sylvainpolletvillard/ObjectModel">GitHub  repository</a>.</p>
	</section>

	<hr>

    <section id="doc-basic-model">
        <h2>Basic Models</h2>
        <p><code>Model</code> is the library namespace and the constructor function for Models. It takes as argument a <i>model definition</i>, and returns a <i>model constructor</i>.
            Basic model constructor validate the argument passed against the model definition, and return the validated value.</p>

        <div class="panels two">
            <div class="panel">
                <span class="legend">Model</span>
            <pre><code class="language-javascript">var NumberModel = Model(Number); // 'new' keyword is optional</code></pre>
            </div>
            <div class="panel">
                <span class="legend">Instance</span>
				<pre><code class="language-javascript">var x = NumberModel("42"); // 'new' keyword is optional</code>
<code class="language-none exception">TypeError: expecting Number, got String "42"</code></pre>
            </div>
        </div>
    </section>

	<section id="doc-object-model">
		<h2>Object Models</h2>
		<p>Object models validate nested object properties against a definition tree. You may consider them as definitions of classes with advanced validation options. They provide automatic validation at initial and future assignments of the properties of the instance objects.</p>
		<div class="panels two">
			<div class="panel">
				<span class="legend">Model</span>
            <pre><code class="language-javascript">var Order = Model({ // or Model.Object
	product: {
		name: String,
		quantity: Number,
	},
	orderDate: Date
});</code></pre>
			</div>
			<div class="panel">
				<span class="legend">Instance</span>
				<pre><code class="language-javascript">var myOrder = Order({
	product: { name: "Apple Pie", quantity: 0 },
	orderDate: new Date()
});

myOrder.product.quantity = 2; // no exceptions thrown
myOrder.product.quantity = false; //try to assign a Boolean</code>
<code class="language-none exception">TypeError: expecting product.quantity to be Number, got Boolean false</code></pre>
			</div>
		</div>
	</section>

	<hr>

	<section id="doc-optional-properties">
		<h2>Optional properties</h2>
		<p>By default, model properties are mandatory. That means all properties defined are required on instance declaration, otherwise an exception will be raised. But you can specify a property to be optional by using the bracket notation, borrowed from the JSDoc specification:</p>
		<div class="panels two">
			<div class="panel">
				<span class="legend">Model</span>
            <pre><code class="language-javascript">var UserInfo = new Model({
	email: String, // mandatory
	name: [String] // optional
});</code></pre>
			</div>
			<div class="panel">
				<span class="legend">Instance</span>
<pre><code class="language-javascript">var stan = new UserInfo({ email: "stan@smith.com" }); // no exceptions
var roger = new UserInfo({ name: "Roger" }); // email is mandatory</code>
<code class="language-none exception">TypeError: expecting email to be String, got undefined</code></pre>
			</div>
		</div>
	</section>

	<hr>

	<section id="doc-multiple-types">
		<h2>Multiple types</h2>
		<p>Several valid types can be specified for one property, aka union types. So optional properties are actually union types between the original type and the value <code>undefined</code>. To declare an optional union type, add <code>undefined</code> to the list. If you pass an empty array, it means the property is watched for changes but can be of any type.</p>
		<div class="panels two">
			<div class="panel">
				<span class="legend">Model</span>
            <pre><code class="language-javascript">var Animation = new Model({
	delay: [Number, String], // can be a Number or a String
	easing: [Boolean, String, undefined]
	// optional property which can be a Boolean or a String
});</code></pre>
			</div>
			<div class="panel">
				<span class="legend">Instance</span>
<pre><code class="language-javascript">var opening = new Animation({ delay: 300 }); // easing is optional
opening.delay = "fast"; // String is a valid type
opening.delay = null;</code>
<code class="language-none exception">TypeError: expecting delay to be Number or String, got null</code>
<code class="language-javascript">opening.easing = true; // Boolean is a valid type
opening.easing = 1;</code>
<code class="language-none exception">TypeError: expecting easing to be Boolean or String or undefined, got Number 1</code></pre>
			</div>
		</div>
	</section>

	<hr>

	<section id="doc-value-checking">
		<h2>Value checking and enumerations</h2>
		<p>Instead of types, values can be specified for model properties. The property value must match the model one. If a regular expression is passed, the value must match it. Use brackets notation for value enumerations. Note that values and types can be mixed for one property.</p>
		<div class="panels">
			<div class="panel">
				<span class="legend">Model</span>
            <pre><code class="language-javascript">var Shirt = new Model({
	category: "clothes", // the only acceptable value is "clothes"
	size: [Number, "M", /^X{0,2}[SL]$/], // valid values: 38, 42, "S", "M", "L", "XL", "XXL"...
	color: ["black","white", new RegExp("^#([A-F0-9]{6})$"), undefined] // valid values: "black", "#FF0000", undefined...
});</code></pre>
			</div>
		</div>
	</section>

    <hr>

	<section id="doc-null-safe">
		<h2>Null-safe object traversal</h2>
		<p>When you want to traverse nested objects, you always have to worry about the null pointer exception. Some languages such as Groovy have a safe navigation operator represented by <code>?.</code> to safely navigate through potential null references. In JavaScript, there is no such solution so you have to manually check for <code>undefined/null</code> values at each level of the object. But within an Object Model, declared properties are null-safe for traversal: every instance complete its structure with undefined properties according to the model.</p>
		<div class="panels two">
			<div class="panel">
				<span class="legend">Model</span>
            <pre><code class="language-javascript">var Config = new Model({
	local: {
		time: {
			format: ["12h","24h", undefined]
		}
	}
});

var initialConfig = { local: undefined }; // classic object
var modelConfig = Config(initialConfig); // object model</code></pre>
			</div>
			<div class="panel">
				<span class="legend">Traversal</span>
            <pre><code class="language-javascript">if(initialConfig.local.time.format === "12h"){ hour %= 12; }</code>
<code class="language-none exception">TypeError: Cannot read property 'time' of undefined</code>

<code class="language-javascript">// so to prevent this exception, we have to check this way:
if(initialConfig != null
&& initialConfig.local != null
&& initialConfig.local.time != null
&& initialConfig.local.time.format === "12h"){
	hour %= 12;
}

// with object models, no worries :)
if(modelConfig.local.time.format === "12h"){ hour %= 12; }
// modelConfig.local.time.format returns undefined</code></pre>
			</div>
		</div>
	</section>

	<hr>

	<section id="doc-default-values">
		<h2>Default values assignement</h2>
		<p>To specify default values for some properties of your model, put them in the model prototype. You can also use the <code>defaults</code> method as a shorthand for setting all the default values at once. If these are not defined at object instanciation, their default value will be assigned.</p>
		<div class="panels two">
			<div class="panel">
				<span class="legend">Model</span>
            <pre><code class="language-javascript">var FileInfo = Model({
	name: String,
	size: [Number],
	creationDate: [Date],
	writable: Boolean
}).defaults({
	name: "Untitled file",
	size: 0,
	writable: true
});</code></pre>
			</div>
			<div class="panel">
				<span class="legend">Instance</span>
<pre><code class="language-javascript">var file = new FileInfo({ writable: false });</code>
<code class="language-javascript">file.name; // name is mandatory but a default value was passed</code>
<code class="language-none log">"Untitled file"</code>
<code class="language-javascript">file.size; // size is optional, but the default value still apply</code>
<code class="language-none log">0</code>
<code class="language-javascript">file.creationDate; // no default value was passed for this property</code>
<code class="language-none log">undefined</code>
<code class="language-javascript">file.writable; // passed value overrides default value</code>
<code class="language-none log">false</code>
<code class="language-javascript">Object.keys(file);</code>
<code class="language-none log">["name","size","creationDate","writable"]</code></pre>
			</div>
		</div>
	</section>

	<hr>

	<section id="doc-composition">
		<h2>Composition</h2>
		<p>Models declared can also be used for type checking, allowing you to compose structures of objects. Note that the sub-models do not necessarily need to be instantiated through the model constructor to be considered valid: only the definition of the sub-model must be respected. This allows you, for example, to parse composed objects from JSON in one step.</p>

		<div class="panels two">
			<div class="panel">
				<span class="legend">Model</span>
            <pre><code class="language-javascript">var Person = Model({
	name: String,
	age: [Number]
});

var Lovers = Model({
	man: Person,
	woman: Person
});</code></pre>
			</div>
			<div class="panel">
				<span class="legend">Instance</span>
            <pre><code class="language-javascript">var joe = { name: "Joe", age: 42 };
var ann = new Person({
	name: joe.name + "'s wife",
	age: joe.age - 5
});

var joe_and_ann = Lovers({
   man: joe,
   woman: ann
});</code></pre>
			</div>
		</div>
	</section>

	<hr>

	<section id="doc-extensions">
		<h2>Inheritance by extensions</h2>
		<p>Extensions create new models based on existing model definitions. You can declare new properties or modify prevous ones. Therefore, it is an easy way to reproduce subtyping and class inheritance.
		But it goes further: unlike classical inheritance, extensions can mix any number of parent models definitions and assertions.</p>
		<div class="panels two">
			<div class="panel">
				<span class="legend">Model</span>
            <pre><code class="language-javascript">var Person = Model({
	name: String,
	female: Boolean
});

var Mother = Person.extend({
	female: true,
	child: Person
});</code></pre>
			</div>
			<div class="panel">
				<span class="legend">Instance</span>
            <pre><code class="language-javascript">var joe = new Person({ name: "Joe", female: false });
var ann = new Person({ name: "Joe's wife", female: true });
var joanna = new Person({ name: "Joe's daughter", female: true });

Mother.isValidModelFor(ann);</code>
<code class="language-none log">false</code>
<code class="language-javascript">ann.child = joanna;
Mother.isValidModelFor(ann);</code>
<code class="language-none log">true</code>
<code class="language-javascript">ann = Mother(ann); // cast ann to Mother model
ann instanceof Mother && ann instanceof Person</code>
<code class="language-none log">true</code>
<code class="language-javascript">joe = Mother(joe); // try to cast joe to Mother model</code>
<code class="language-none exception">TypeError: expecting female to be true, got Boolean false</code></pre>
			</div>
		</div>
	</section>

	<hr>

	<section id="doc-assertions">
		<h2>Assertions for custom validation tests</h2>
		<p>You can add to your models any number of assertions that are custom test functions applied on the values of instances of the model. For example, we have this weird behaviour in JavaScript that makes
			<code>NaN</code> and <code>Infinity</code> considered as Number, which is probably not what you want. Just add a simple assertion to get rid of them.</p>
		<div class="panels two">
			<div class="panel">
				<span class="legend">Model</span>
<pre><code class="language-javascript">var Integer = Model(Number).assert(Number.isFinite, Number.isInteger);

function isPrime(n) {
	for (var i=2, m=Math.sqrt(n); i <= m ; i++){
		if(n%i === 0) return false;
	}
	return true;
}

var PrimeNumber = Integer.extend().assert(isPrime);
// extend to not add isPrime assertion to the Integer model
</code></pre>
			</div>
			<div class="panel">
				<span class="legend">Instance</span>
                <pre><code class="language-javascript">Integer(Math.sqrt(1));</code>
<code class="language-none log">1</code>
<code class="language-javascript">Integer(Math.sqrt(2));</code>
<code class="language-none exception">TypeError: an assertion of the model is not respected: isInteger</code>
<code class="language-javascript">Integer(Math.sqrt(-1));</code>
<code class="language-none exception">TypeError: an assertion of the model is not respected: isFinite</code>

<code class="language-javascript">PrimeNumber(83);</code>
<code class="language-none log">83</code>
<code class="language-javascript">PrimeNumber(87);</code>
<code class="language-none exception">TypeError: an assertion of the model is not respected: isPrime</code></pre>
			</div>
		</div>
	</section>

	<hr>

	<section id="doc-private-and-constants">
		<h2>Private and constant properties</h2>
		<p>Some variable naming conventions are commonly used in JavaScript. For example, a leading underscore is used to specify a <i>_private</i> variable which should not be used outside its class methods. Also, constants are often in <i>ALL_CAPS</i>. Object Model definition follow these conventions by making <i>_underscored</i> properties not enumerable and <i>CAPITALIZED</i> properties not writable.</p>
	</section>

	<div class="panels two">
		<div class="panel">
			<span class="legend">Model</span>
            <pre><code class="language-javascript">var Circle = Model({
	radius: Number, // public
	_diameter: [Number], // private
	UNIT: ["px","cm","mm"], // constant
	_ID: [Number], // private and constant
});
</code></pre>
		</div>
		<div class="panel">
			<span class="legend">Instance</span>
            <pre><code class="language-javascript">var c = new Circle({ radius: 120, UNIT: "px", _ID: 1 });
c.radius = 100;
c.UNIT = "cm";</code>
<code class="language-none exception">TypeError: cannot redefine constant UNIT</code>
<code class="language-javascript">Object.keys(c); // private variables are not enumerated</code>
<code class="language-none log">["radius", "UNIT"]</code></pre>
		</div>
	</div>
	<hr>

	<section id="doc-array-model">
		<h2>Array models</h2>
		<p>Array models validate the array elements types. All the validation options for object models are also available for array model elements: type/value checking, optional properties, union types, enumerations, assertions...</p>
		<div class="panels two">
			<div class="panel">
				<span class="legend">Model</span>
            <pre><code class="language-javascript">var Family = Model({
	father: Father,
	mother: Mother,
	children: Model.Array(Person), // array of Persons
	grandparents: [Model.Array([Mother, Father])]
	            // optional array of Mothers or Fathers
});</code></pre>
			</div>
			<div class="panel">
				<span class="legend">Instance</span>
				<pre><code class="language-javascript">var joefamily = new Family({
	father: joe,
	mother: ann,
	children: [joanna, "dog"]
});</code>
<code class="language-none exception">TypeError: expecting children to be Model.Array({	name: String, female: Boolean }), got Array [{ name: "Joe's daughter", female: true}, "dog"]</code>
</pre>
		</div>
	</div>
		<p>The validation is done on initial array elements passed to the model constructor, then on new elements added through mutator methods. Mutator methods are
			these native functions in the Array prototype that modify the array content: <code>pop</code>, <code>push</code>, <code>reverse</code>, <code>shift</code>,
			<code>sort</code>, <code>splice</code> and <code>unshift</code>. Note that if you expand the array by storing an element at an index greater than the
			current array length (which is commonly considered as a bad practice), the new element and model assertions may not be validated.
			Use the <code>push</code> method instead.</p>
		<div class="panels two">
			<div class="panel">
<pre><code class="language-javascript">var Cards = Model.Array([Number, "J","Q","K"]);
var Hand = Cards.extend("Joker").assert(function(cards){
	return cards.length === 2;
}); // array of 2 Numbers, J, Q, K or Joker</code></pre></div>
			<div class="panel">
<pre><code class="language-javascript">var myHand = new Hand(7, "Joker");
myHand[2] = "K"; // will not trigger validation this way
myHand.push("K"); // use this instead</code>
<code class="language-none exception">TypeError: an assertion of the model is not respected: function (cards){ return cards.length === 2; }</code></pre>
			</div>
		</div>
	</section>

	<hr>

	<section id="doc-function-model">
		<h2>Function models</h2>
		<p>Function models provide validation on input (arguments) and output (return value). All the validation options for Object models are also available for Function models. The arguments passed to <code>Model.Function</code> are the types of the arguments the function will receive. The <code>defaults</code> method of Function models let you specify default values for missing arguments at call. Finally, the <code> return</code> method is used to specify the type of the function return value.</p>

		<div class="panels two">
			<div class="panel">
				<span class="legend">Model</span>
            <pre><code class="language-javascript">var Calculator = Model.Function(Number, ["+","-","*","/"], Number)
	            .defaults(0, "+", 1)
	            .return(Number);</code></pre>
			</div>
			<div class="panel">
				<span class="legend">Instance</span>
            <pre><code class="language-javascript">var calc = new Calculator(function(a, operator, b){
	return eval(a + operator + b);
});

calc(3, "+"); // use default value for 3rd argument</code>
<code class="language-none log">4</code>
<code class="language-javascript">calc(6, "*", null);</code>
<code class="language-none exception">TypeError: expecting arguments[2] to be Number, got null</code></pre>
			</div>
		</div>

		<p>In Object Oriented Programming, we often use model methods that are common to all instances. You can define these methods in the model prototype as you would do with classic JavaScript OOP programming. You can also use the <code>defaults</code> method of the object model that sets the prototype as well. <a href="#doc-default-values">See the 'Default values' section</a>.</p>

		<div class="panels two">
			<div class="panel">
				<span class="legend">Model</span>
            <pre><code class="language-javascript">var Person = Model({
	name: String,
	age: Number
}).defaults({
	// function without arguments returning a String
	sayMyName: Model.Function().return(String)(function(){
		return "my name is " + this.name;
	})
});

// takes one argument of type Person, returns a String
var greetFnModel = Model.Function(Person).return(String);
Person.prototype.greet = greetFnModel(function(otherguy){
	return "Hello "+ otherguy.name + ", " + this.sayMyName();
});</code></pre>
			</div>
			<div class="panel">
				<span class="legend">Instance</span>
            <pre><code class="language-javascript">var joe = new Person({ name: "Joe", age: 28 });
var ann = new Person({ name: "Ann", age: 23 });

joe.sayMyName();</code>
<code class="language-none log">my name is Joe</code>
<code class="language-javascript">joe.greet(ann);</code>
<code class="language-none log">Hello Ann, my name is Joe</code>
<code class="language-javascript">joe.greet("dog");</code>
<code class="language-none exception">TypeError: expecting arguments[0] to be {
	name: String,
	age: Number,
	sayMyName: Model.Function().return(String)
}, got String "dog"</code></pre>
			</div>
		</div>

	</section>

	<hr>

    <section id="api">
        <h2>Full API</h2>
        <dl>
            <dt><a href="#doc-basic-model">Model</a> <code>new Model(definition)</code></dt>
            <dd>Constructor for basic models. If a litteral object is passed, return an object model.</dd>

            <dt><a href="#doc-object-model">Model.Object</a> <code>new Model.Object(definition)</code></dt>
            <dd>Constructor for object models</dd>

            <dt><a href="#doc-array-model">Model.Array</a> <code>new Model.Array(itemDefinition)</code></dt>
            <dd>Constructor for array models</dd>

            <dt><a href="#doc-function-model">Model.Function</a> <code>new Model.Function(definitionArgument1, definitionArgument2...)</code></dt>
            <dd>Constructor for function models</dd>
        </dl>
        <h3>Model methods and properties</h3>
        <dl>
            <dt>definition <code>model.definition</code></dt>
            <dd>Returns the model definition</dd>

            <dt>assertions <code>model.assertions</code></dt>
            <dd>Returns the list of model assertions</dd>

            <dt>isValidModelFor <code>model.isValidModelFor(value)</code></dt>
            <dd>Returns <code>true</code> if the value passed validate the model definition. Does not necessarily mean value has been instanciated through the model constructor, otherwise use
                <code class="language-javascript">value instanceof model</code>.
            </dd>

            <dt><a href="#doc-extensions">extend</a> <code>model.extend(otherDefinition1, otherDefinition2...)</code></dt>
            <dd>Returns a new model based on the initial model definition merged with other definitions passed. Assertions are preserved too.</dd>

            <dt><a href="#doc-assertions">assert</a> <code>model.assert(assertion1, assertion2...)</code></dt>
            <dd>Add any number of test functions to the model that must all return <code>true</code> to validate the instance.</dd>
        </dl>
        <h3>Object models</h3>
        <dl>
            <dt>defaults <code>objectModel.defaults(defaultValuesObject)</code></dt>
            <dd>Merge the object passed with the model prototype to set defaults values for some model properties.</dd>
        </dl>
        <h3>Function models</h3>
        <dl>
            <dt>defaults <code>functionModel.defaults(defaultValueArgument1, defaultValueArgument2...)</code></dt>
            <dd>Set a default value for function arguments.</dd>

            <dt>return <code>functionModel.return(returnValueDefinition)</code></dt>
            <dd>Set the definition of the return value. Each call to the function must return a validated value, otherwise an exception will be raised.</dd>
        </dl>
    </section>

    <hr>

    <section id="common-questions">
        <h2>Common questions</h2>
        <h3>How do I declare a constructor function to be called on instanciation before validating my model ?</h3>
        <p>The easiest way is to declare this function as a property of your model constructor, then use it to instanciate your models instead of the model
	        constructor itself:</p>
        <pre><code class="language-javascript">var User = Model.Object({
    firstName: String,
    lastName: String,
    fullName: String
});

User.create = function(properties){
    properties.fullName = properties.firstName + " " + properties.lastName;
    return new User(properties);
};

var joe = User.create({ firstName: "Joe", lastName: "Dalton" });</code></pre>

        <h3>How should I deal with circular references in my model definitions ?</h3>
        <p>You can't refer to a model constructor or model instance that is not yet defined, so you have to update the definition afterwards.</p>
          <pre><code class="language-javascript">var Honey = Model({
   sweetie: [] // Sweetie is not yet defined
});

var Sweetie = Model({
   honey: Honey
});

Honey.definition.sweetie = [Sweetie];

var joe = Honey({ sweetie: undefined }); // ann is not yet defined
var ann = Sweetie({ honey: joe });
joe.sweetie = ann;</code></pre>
    </section>

	<section>
		<h2>I have a question / suggestion / bug to report</h2>
		<p>Please check the documentation twice, then open an issue on the <a href="https://github.com/sylvainpolletvillard/ObjectModel/issues">Github repository</a></p>
	</section>

	<hr>
	<footer><a href="LICENSE">MIT licensed</a> - &copy; 2015 syllab.fr</footer>
</div>

<script src="site/js/main.js"></script>
<script src="site/lib/prism.js"></script>
<script src="dist/object-model.js"></script>

</body>
</html>
