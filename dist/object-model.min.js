// ObjectModel v4.4.5 - http://objectmodel.js.org
// MIT License - Sylvain Pollet-Villard
const t=Object.prototype,e=Object.getPrototypeOf,r=Object.setPrototypeOf,n=(e,r)=>t.hasOwnProperty.call(e,r),i=(t,e)=>e instanceof t,o=t=>"function"==typeof t,s=t=>t&&"object"==typeof t,a=t=>"string"==typeof t,l=r=>s(r)&&e(r)===t,c=t=>t&&o(t[Symbol.iterator]),f=(t,e)=>new Proxy(t,e),u=(t,e={})=>{for(let r in e)if(l(e[r])){const n={};u(n,t[r]),u(n,e[r]),t[r]=n}else t[r]=e[r];return t},p=(t,e,r,n=!1)=>{Object.defineProperty(t,e,{value:r,enumerable:n,writable:!0,configurable:!0})},h=(t,e,n)=>{t.prototype=Object.assign(Object.create(e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),n),r(t,e)},d=Symbol(),g=Symbol(),y=Symbol(),m=Symbol(),v=(t,e,n,o,s,a)=>{const l=function(t=l.default,e){return a&&!i(l,this)?new l(t):(o&&(t=o(t,l,this)),e===g||x(l,t)?s&&e!==m?f(t,s(l)):t:void 0)};return n&&h(l,n),r(l,e.prototype),l.constructor=e,l.definition=t,l.assertions=[...l.assertions],p(l,"errors",[]),delete l.name,l},b=(t,e,r)=>i(e,t)?t:s(t)||o(t)||void 0===t?(u(r,e.default),e.parentClass&&u(t,new e.parentClass(t)),u(r,t),r):t,$=(t,e,r)=>(h(t,e,r),t.assertions.push(...e.assertions),t),S=(t,e,r,n,i)=>{t.push({expected:e,received:r,path:n,message:i})},w=(e,r=e.errorCollector)=>{const n=e.errors.length;if(n>0){const n=e.errors.map((r=>{var n;return r.message||(r.message="expecting "+(r.path?r.path+" to be ":"")+P(r.expected)+", got "+(null!=r.received?(n=r.received,t.toString.call(n).match(/\s([a-zA-Z]+)/)[1]+" "):"")+k(r.received)),r.model=e,r}));e.errors.length=0,r.call(e,n)}return n},O=t=>t&&e(t)&&i(K,e(t).constructor),j=t=>{if(l(t)){t={};for(let e in t)t[e]=j(t[e])}return Array.isArray(t)?1===t.length?[t[0],void 0,null]:t:[t]},P=(t,e)=>{const r=j(t).map((t=>k(t,e)));return r.length>1?r.join(" or "):r[0]},A=(t,e=[])=>(e.length>0&&(t=[].concat(t,...[].concat(e)).filter(((t,e,r)=>r.indexOf(t)===e))),t),x=(t,e)=>(t[d](e,null,t.errors,[],!0),!w(t)),C=(t,e,r,n,o,s)=>{const a=o.indexOf(e);if(-1!==a&&-1!==o.indexOf(e,a+1))return t;if(Array.isArray(e)&&1===e.length&&null!=t&&(e=e[0]),i(K,e))s&&(t=N(t,e)),e[d](t,r,n,o.concat(e),s);else if(l(e))for(let i in e){const a=t?t[i]:void 0;C(a,e[i],M(r,i),n,o,s)}else{if(j(e).some((e=>R(t,e,r,o,s))))return s?N(t,e):t;S(n,e,t,r)}return t},R=(t,e,r,n,s)=>{if(e===H)return!0;if(null==t)return t===e;if(l(e)||i(K,e)){const i=[];return C(t,e,r,i,n,s),!i.length}return i(RegExp,e)?e.test(t):e===Number||e===Date?t.constructor===e&&!isNaN(t):t===e||o(e)&&i(e,t)||t.constructor===e},F=(t,e,r,n=e.errors)=>{for(let i of e.assertions){let s;try{s=i.call(e,t)}catch(t){s=t}if(!0!==s){const a=o(i.description)?i.description:(t,e)=>`assertion "${i.description}" returned ${k(t)} for ${r?r+" =":"value"} ${k(e)}`;S(n,i,t,r,a.call(e,s,t,r))}}},k=(e,r=[])=>{if(r.length>15||r.includes(e))return"...";if(null==e)return String(e);if(a(e))return`"${e}"`;if(i(K,e))return e.toString(r);if(r.unshift(e),o(e))return e.name||e.toString();if(i(Map,e)||i(Set,e))return k([...e]);if(Array.isArray(e))return`[${e.map((t=>k(t,r))).join(", ")}]`;if(e.toString&&e.toString!==t.toString)return e.toString();if(s(e)){const t=Object.keys(e),n="\t".repeat(r.length);return`{${t.map((t=>`\n${n+t}: ${k(e[t],[...r])}`)).join(", ")} ${t.length?`\n${n.slice(1)}`:""}}`}return String(e)},M=(t,e)=>t?t+"."+e:e,E=(t,e,r,i,o,s,a)=>{const l=M(r,o),c=t.conventionForPrivate(o),f=t.conventionForConstant(o),u=n(i,o),p=u&&Object.getOwnPropertyDescriptor(i,o);o in e&&(c&&!s||f&&void 0!==i[o])&&D(`modify ${c?"private":"constant"} property ${o}`,t),a(),n(e,o)&&C(i[o],e[o],l,t.errors,[]),F(i,t,l);const h=t.errors.length;return h&&(u?Object.defineProperty(i,o,p):delete i[o],w(t)),!h},D=(t,e)=>{e.errors.push({message:"cannot "+t})},N=(t,e=[])=>{if(!t||l(e)||i(_,e)||O(t))return t;const r=j(e),n=[];for(let e of r)i(K,e)&&!i(_,e)&&e.test(t)&&n.push(e);return 1===n.length?new n[0](t,g):(n.length>1&&console.warn(`Ambiguous model for value ${k(t)}, could be ${n.join(" or ")}`),t)},T=(t,e,r,i)=>({get(s,c){if(c===y)return s;if(!a(c))return Reflect.get(s,c);const u=M(r,c),p=n(e,c),h=e[c];if(!i&&p&&t.conventionForPrivate(c))return D(`access to private property ${u}`,t),void w(t);let d=s[c];return p&&d&&n(s,c)&&!l(h)&&!O(d)&&Reflect.set(s,c,d=N(d,h)),o(d)&&"constructor"!==c&&!i?f(d,{apply(t,e,r){i=!0;const n=Reflect.apply(t,e,r);return i=!1,n}}):(l(h)&&!d&&(s[c]=d={}),((t,e,r,n,i)=>l(r)?f(t,T(e,r,n,i)):N(t,r))(d,t,h,u,i))},set:(n,o,s)=>E(t,e,r,n,o,i,(()=>Reflect.set(n,o,N(s,e[o])))),deleteProperty:(n,o)=>E(t,e,r,n,o,i,(()=>Reflect.deleteProperty(n,o))),defineProperty:(n,o,s)=>E(t,e,r,n,o,i,(()=>Reflect.defineProperty(n,o,s))),has:(r,n)=>Reflect.has(r,n)&&Reflect.has(e,n)&&!t.conventionForPrivate(n),ownKeys:r=>Reflect.ownKeys(r).filter((r=>Reflect.has(e,r)&&!t.conventionForPrivate(r))),getOwnPropertyDescriptor(r,n){let i;return t.conventionForPrivate(n)||(i=Object.getOwnPropertyDescriptor(e,n),void 0!==i&&(i.value=r[n])),i}});function K(t){return l(t)?new z(t):new _(t)}function _(t){return v(t,_)}function z(t){return v(t,z,Object,b,(e=>T(e,t)),!0)}Object.assign(K.prototype,{name:"Model",assertions:[],conventionForConstant:t=>t.toUpperCase()===t,conventionForPrivate:t=>"_"===t[0],toString(t){return n(this,"name")?this.name:P(this.definition,t)+((e=this.assertions).length?`(${e.map((t=>t.name||t.description||t))})`:"");var e},as(t){return p(this,"name",t),this},defaultTo(t){return this.default=this(t),this},[d](t,e,r,n,i){C(t,this.definition,e,r,n,i),F(t,this,e,r)},test(t,r){let i=this;for(;!n(i,"errorCollector");)i=e(i);const o=i.errorCollector;let s;return i.errorCollector=t=>{s=!0,r&&r.call(this,t)},new this(t),i.errorCollector=o,!s},errorCollector(t){const e=new TypeError(t.map((t=>t.message)).join("\n"));throw e.stack=e.stack.replace(/\n.*object-model(.|\n)*object-model.*/,""),e},assert(t,e=k(t)){return p(t,"description",e),this.assertions=this.assertions.concat(t),this}}),K.CHECK_ONCE=m,h(_,K,{extend(...t){const e=$(new _(A(this.definition,t)),this);for(let r of t)i(_,r)&&e.assertions.push(...r.assertions);return e}}),h(z,K,{defaultTo(t){const e=this.definition;for(let r in t)n(e,r)&&(t[r]=C(t[r],e[r],r,this.errors,[],!0));return w(this),this.default=t,this},toString(t){return k(this.definition,t)},extend(...t){const r={...this.definition},n={...this.prototype},a={...this.default},l=[];for(let e of t)i(K,e)&&(u(r,e.definition),u(a,e.default),l.push(...e.assertions)),o(e)&&u(n,e.prototype),s(e)&&u(r,e);const c=$(new z(r),this,n).defaultTo(a);return c.assertions=[...this.assertions,...l],e(this)!==z.prototype&&(c.parentClass=this),c},[d](t,e,r,n,i){s(t)?C(t[y]||t,this.definition,e,r,n,i):S(r,this,t,e),F(t,this,e,r)}});const H=f(_(),{apply(t,e,[r]){const n=Object.create(H);return n.definition=r,n}});H.definition=H,H.toString=()=>"Any",H.remaining=function(t){this.definition=t},h(H.remaining,H,{toString(){return"..."+P(this.definition)}}),H[Symbol.iterator]=function*(){yield new H.remaining(this.definition)};const U=(t,e,r,i,s,a,l)=>v(r,e,t,i,(e=>Object.assign({getPrototypeOf:()=>e.prototype,get(r,i){if(i===y)return r;const l=r[i];return o(l)?f(l,{apply(o,l,c){if(n(a,i)){const[n,l=c.length-1,f]=a[i];for(let r=n;r<=l;r++){const n=f?f(r):e.definition;c[r]=C(c[r],n,`${t.name}.${i} arguments[${r}]`,e.errors,[],!0)}if(e.assertions.length>0){const t=s(r);o.apply(t,c),F(t,e,`after ${i} mutation`)}w(e)}return o.apply(r,c)}}):l}},l)));function W(t){const e=U(Array,W,t,(t=>Array.isArray(t)?t.map((t=>N(t,e.definition))):t),(t=>[...t]),{copyWithin:[],fill:[0,0],pop:[],push:[0],reverse:[],shift:[],sort:[],splice:[2],unshift:[0]},{set:(t,r,n)=>Z(e,t,r,n,((t,e)=>t[r]=e),!0),deleteProperty:(t,r)=>Z(e,t,r,void 0,(t=>delete t[r]))});return e}h(W,K,{toString(t){return"Array of "+P(this.definition,t)},[d](t,e,r,n,i){Array.isArray(t)?(t[y]||t).forEach(((t,o)=>C(t,this.definition,`${e||"Array"}[${o}]`,r,n,i))):S(r,this,t,e),F(t,this,e,r)},extend(...t){return $(new W(A(this.definition,t)),this)}});const Z=(t,e,r,n,i,o)=>{const s=`Array[${r}]`;+r>=0&&(o||r in e)&&(n=C(n,t.definition,s,t.errors,[],!0));const a=[...e];i(a),F(a,t,s);const l=!w(t);return l&&i(e,n),l};function q(...t){return v({arguments:t},q,Function,null,(t=>({getPrototypeOf:()=>t.prototype,get:(t,e)=>e===y?t:t[e],apply(e,r,n){const o=t.definition,s=o.arguments.find((t=>i(H.remaining,t))),a=s?Math.max(n.length,o.arguments.length-1):o.arguments.length;for(let e=0;e<a;e++){const r=s&&e>=o.arguments.length-1?s.definition:o.arguments[e];n[e]=C(n[e],r,`arguments[${e}]`,t.errors,[],!0)}let l;return F(n,t,"arguments"),t.errors.length||(l=Reflect.apply(e,r,n),"return"in o&&(l=C(l,o.return,"return value",t.errors,[],!0))),w(t),l}})))}function B(t,e){const r=t=>0===t?n.definition.key:n.definition.value,n=U(Map,B,{key:t,value:e},(t=>c(t)?new Map([...t].map((t=>t.map(((t,e)=>N(t,r(e))))))):t),(t=>new Map(t)),{set:[0,1,r],delete:[],clear:[]});return n}function G(t){const e=U(Set,G,t,(t=>c(t)?new Set([...t].map((t=>N(t,e.definition)))):t),(t=>new Set(t)),{add:[0,0],delete:[],clear:[]});return e}h(q,K,{toString(t=[]){let e=`Function(${this.definition.arguments.map((e=>P(e,[...t]))).join(", ")})`;return"return"in this.definition&&(e+=" => "+P(this.definition.return,t)),e},return(t){return this.definition.return=t,this},[d](t,e,r){o(t)||S(r,"Function",t,e)}}),h(B,K,{toString(t){return`Map of ${P(this.definition.key,t)} : ${P(this.definition.value,t)}`},[d](t,e,r,n,o){if(i(Map,t)){e=e||"Map";for(let[i,s]of t)C(i,this.definition.key,`${e} key`,r,n,o),C(s,this.definition.value,`${e}[${k(i)}]`,r,n,o)}else S(r,this,t,e);F(t,this,e,r)},extend(t,e){return $(new B(A(this.definition.key,t),A(this.definition.value,e)),this)}}),h(G,K,{toString(t){return"Set of "+P(this.definition,t)},[d](t,e,r,n,o){if(i(Set,t))for(let i of t.values())C(i,this.definition,`${e||"Set"} value`,r,n,o);else S(r,this,t,e);F(t,this,e,r)},extend(...t){return $(new G(A(this.definition,t)),this)}});export{H as Any,W as ArrayModel,_ as BasicModel,q as FunctionModel,B as MapModel,K as Model,z as ObjectModel,G as SetModel};
//# sourceMappingURL=object-model.min.js.map
