<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="description" content="ObjectModel : Strong Dynamically Typed Object Modeling for JavaScript">
	<meta name="author" content="Sylvain Pollet-Villard">

	<title>ObjectModel</title>

	<link rel="icon" type="image/png" href="docs/favicon-32x32.png" sizes="32x32"/>
	<link rel="icon" type="image/png" href="docs/favicon-16x16.png" sizes="16x16"/>
	<link rel="shortcut icon" href="docs/favicon.ico" type="image/x-icon">

	<link rel="stylesheet" href="docs/style/main.css"/>
	<script src="https://cdn.polyfill.io/v2/polyfill.min.js"></script>

	<script defer src="docs/lib/prism.js"></script>
	<script defer src="docs/js/main-compiled.js"></script>
	<script defer src="dist/object-model.js"></script>
</head>

<body>
<button id="menu-button" class="lines-button arrow arrow-left" aria-label="Toggle Navigation">
	<span class="lines"></span>
</button>

<nav id="menu">
	<a class="title download-link" href="#download">
		<h2>Download</h2>
	</a>
	<hr>
	<a class="title github-link" href="https://github.com/sylvainpolletvillard/ObjectModel" target="_blank">
		<h2>View on Github</h2>
	</a>
	<hr>
	<div>
		<a href="#introduction" class="title">Introduction</a>
		<ul>
			<li><a href="#introduction">What is it</a></li>
			<li><a href="#video-demo">Video demo</a></li>
			<li><a href="#features">Features</a></li>
		</ul>
	</div>
	<hr>
	<div>
		<a href="#doc-basic-model" class="title">Documentation</a>
		<ul>
			<li><a href="#doc-basic-model">Basic models</a></li>
			<li><a href="#doc-object-model">Object models</a></li>
			<li><a href="#doc-es6-classes">Using ES6 class</a></li>
			<li><a href="#doc-optional-properties">Optional properties</a></li>
			<li><a href="#doc-multiple-types">Multiple types</a></li>
			<li><a href="#doc-value-checking">Value checking and enumerations</a></li>
			<li><a href="#doc-null-safe">Null-safe object traversal</a></li>
			<li><a href="#doc-default-values">Default values</a></li>
			<li><a href="#doc-composition">Composition</a></li>
			<li><a href="#doc-extensions">Inheritance by extensions</a></li>
			<li><a href="#doc-multiple-inheritance">Multiple inheritance</a></li>
			<li><a href="#doc-assertions">Assertions for custom tests</a></li>
			<li><a href="#doc-private-and-constants">Private and constant properties</a></li>
			<li><a href="#doc-array-model">Array models</a></li>
			<li><a href="#doc-function-model">Function models</a></li>
			<li><a href="#doc-custom-collectors">Custom error collectors</a></li>
			<li><a href="#api">Full API</a></li>
			<li><a href="#common-models">Commonly used models</a></li>
			<li><a href="#common-questions">Common questions</a></li>
		</ul>
	</div>
	<hr>
</nav>

<div id="page">

	<header class="header">
		<img src="docs/res/logo.png" alt="ObjectModel" width="800" height="150">
		<hr>
		<p class="description">Strong Dynamically Typed Object Modeling for JavaScript</p>
	</header>

	<section id="introduction" class="grid">

		<div class="description">
			<h2 id="what-is-it">What is this library ?</h2>

			<p>ObjectModel intends to bring <strong>strong dynamic type checking</strong> to your web applications. Contrary to static type-checking solutions like <a href="https://www.typescriptlang.org" target="_blank">TypeScript</a> or <a href="https://flowtype.org" target="_blank">Flow</a>, ObjectModel can also validate data at runtime: JSON from the server, form inputs, content from <code>localStorage</code>, external libraries...</p>

			<p>By leveraging <strong>ES6 Proxies</strong>, this library ensures that your variables always match the model definition and validation constraints you added to them. Thanks to the generated exceptions, it will help you spot potential bugs and save you time spent on debugging. ObjectModel is also very easy to master: no new language to learn, no new tools, no compilation step, just a minimalist and intuitive API in a plain old JS micro-library.</p>

			<p>Validating at runtime also brings many other benefits: you can define your own types, use them in complex model definitions with custom assertions that can even change depending on your application state. Actually it goes much further than just type safety. Go on and see for yourself.</p>
		</div>

		<div id="video-demo">
			<iframe src="https://www.youtube.com/embed/zmojfyNH_EE?rel=0&amp;showinfo=0"
			        width="640" height="360" frameborder="0" allowfullscreen>
			</iframe>
		</div>
	</section>

	<hr>

	<section id="features-and-download" class="grid">
		<div id="features">
			<h2>What's inside the box ?</h2>
			<p>Many features, hopefully neither too much nor too few:</p>
			<ul>
				<li>Typed structures: objects, arrays, maps, sets, functions...</li>
				<li>Union types</li>
				<li>Enumerations</li>
				<li>Custom assertions</li>
				<li>Optional properties</li>
				<li>Default values</li>
				<li>Null-safe object traversal</li>
				<li>Easy composition or inheritance</li>
				<li>Constants and private properties based on name conventions</li>
				<li>Explicit error messages</li>
				<li>Customizable error handlers</li>
				<li>all in
					<strong class="size-min">9.85 KB</strong> minified,
					<strong class="size-gzip">3.68 KB</strong> gzipped,
					even less when using tree-shaking
				</li>
			</ul>
		</div>

		<div id="download">
			<h2>Download</h2>
			<h3>Current version: v<span class="version">3.0.0</span></h3>
			<ul>
				<li>From <a href="https://www.npmjs.com/package/objectmodel" target="_blank">NPM</a> :
					<code>npm install objectmodel</code>
				</li>
				<li>Minified file (<strong class="size-min">9.85 KB</strong>,
					<strong class="size-gzip">3.68 KB</strong> gzipped) :
					<a href="dist/object-model.min.js">object-model.min.js</a>
				</li>
				<li>Source files :
					<a class="link-zip" href="https://github.com/sylvainpolletvillard/ObjectModel/archive/v3.0.0.zip">object-model-3.0.0.zip</a>
				</li>
			</ul>

			<h3>Changelog and previous releases</h3>

			<p><strong>Note: ObjectModel v3 only targets ES2015-compliant environments.</strong></p>
			<p>If you need to support older browsers, please use the <a href="docs/v2">2.x version</a> instead.</p>

			<p>Take a look at
				<a href="https://github.com/sylvainpolletvillard/ObjectModel/releases" target="_blank">Github Releases</a>
				and <a href="#common-questions">Browsers support</a> section for more information.
			</p>
		</div>

		<div>
			<h2>Support</h2>
			<p>Please report bugs on the
				<a href="https://github.com/sylvainpolletvillard/ObjectModel" target="_blank">GitHub repository</a>.
			</p>
			<p>You can also ask for support on the
				<a href="https://gitter.im/sylvainpolletvillard/ObjectModel" target="_blank">Gitter channel</a>.
			</p>
		</div>
	</section>

	<hr>

	<section id="doc-basic-model" class="grid doc-code-code">
		<div class="doc">
			<h2>Basic models</h2>
			<p>Basic models simply validate a variable against the model definition passed as argument, and return the validated value. <code>BasicModel</code> constructor takes a <i>model definition</i> as the only argument. They are generally used to declare all the basic generic types that you will use in your application. You can find a list of <a href="#common-models">common basic models here</a>.</p>
		</div>

		<div class="panel panel1">
			<span class="legend">Model</span>
			<pre><code class="language-javascript">const NumberModel = BasicModel(Number);
// 'new' keyword is optional for models and model instances</code></pre>
		</div>

		<div class="panel panel2">
			<span class="legend">Instance</span>
			<pre><code class="language-javascript">let x = NumberModel("42");</code>
<code class="language-none exception">TypeError: expecting Number, got String "42"</code></pre>
		</div>
	</section>

	<hr>

	<section id="doc-object-model" class="grid doc-code-code">
		<div class="doc">
			<h2>Object models</h2>
			<p>Object models validate nested object properties against a definition tree. They provide automatic validation at initial and future assignments of the properties of the instance objects.</p>
			<aside>Note: an object with properties not declared in the definition is still valid, as long as the rest of the definition is respected. If you want to prevent all undeclared properties, you can set the <code>model.sealed</code> property to <code>true</code>. This is the equivalent of <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/seal" target="_blank"><code>Object.seal()</code></a> for object models.</aside>
		</div>

		<div class="panel panel1">
			<span class="legend">Model</span>
			<pre><code class="language-javascript">const Order = new ObjectModel({
	product: {
		name: String,
		quantity: Number,
	},
	orderDate: Date
});</code></pre>
		</div>

		<div class="panel panel2">
			<span class="legend">Instance</span>
			<pre><code class="language-javascript">const myOrder = new Order({
	product: { name: "Apple Pie", quantity: 1 },
	orderDate: new Date()
});

myOrder.product.quantity = 2; // no exceptions thrown
myOrder.product.quantity = false; //try to assign a Boolean</code>
<code class="language-none exception">TypeError: expecting product.quantity to be Number, got Boolean false</code></pre>
		</div>
	</section>

	<hr>

	<section id="doc-model" class="grid doc-code">
		<div class="doc">
			<h2>Model constructor</h2>
			<p><code>Model</code> is the <strong>base class of all models</strong> and can be used as an alias for <code>BasicModel</code> and <code>ObjectModel</code> constructors.</p>
		</div>

		<div class="panel">
			<span class="legend">Example</span>
			<pre><code class="language-javascript">NumberModel instanceof Model && Order instanceof Model // true

Model(String) // return a Basic model
Model({ name: String }) // return an Object model</code></pre>
		</div>
	</section>

	<hr>

	<section id="doc-es6-classes" class="grid doc-code-code">
		<div class="doc">
			<h2>Usage with ES6 classes</h2>
			<p>If you are using ES6 classes in your project, it is very easy to define a model for your classes:</p>
		</div>

		<div class="panel panel1">
			<span class="legend">Model</span>
			<pre><code class="language-javascript">class Character extends Model({ lastName: String, firstName: String }){
   get fullName(){ return `${this.firstName} ${this.lastName}`; }
}</code></pre>
		</div>

		<div class="panel panel2">
			<span class="legend">Instance</span>
			<pre><code class="language-javascript">const rick = new Character({ lastName: "Sanchez", firstName: "Rick" });
rick.lastName = 132;</code>
<code class="language-none exception">TypeError: expecting lastName to be String, got Number 132</code>
<code class="language-javascript">console.log(rick.fullName); // "Rick Sanchez"</code></pre>
		</div>
	</section>

	<hr>

	<section id="doc-optional-properties" class="grid doc-code-code">
		<div class="doc">
			<h2>Optional properties</h2>
			<p>By default, model properties are mandatory. That means all properties defined are required on instance declaration, otherwise an exception will be raised. But you can specify a property to be optional by using the bracket notation, borrowed from the JSDoc specification</p>
		</div>

		<div class="panel panel1">
			<span class="legend">Model</span>
			<pre><code class="language-javascript">const User = ObjectModel({
	email: String, // mandatory
	name: [String] // optional
});</code></pre>
		</div>

		<div class="panel panel2">
			<span class="legend">Instance</span>
			<pre><code class="language-javascript">const stan = User({ email: "stan@smith.com" }); // no exceptions
const roger = User({ name: "Roger" }); // email is mandatory</code>
<code class="language-none exception">TypeError: expecting email to be String, got undefined</code></pre>
		</div>
	</section>

	<hr>

	<section id="doc-multiple-types" class="grid doc-code-code">
		<div class="doc">
			<h2>Multiple types</h2>
			<p>Several valid types can be specified for one property, aka union types. So optional properties are actually union types between the original type and the values <code>undefined</code> and <code>null</code>. To declare an optional union type, add <code>undefined</code> to the list.</p>
		</div>

		<div class="panel panel1">
			<span class="legend">Model</span>
			<pre><code class="language-javascript">const Animation = new ObjectModel({
	// can be a Number or a String
	delay: [Number, String],

	// optional property which can be a Boolean or a String
	easing: [Boolean, String, undefined]
});</code></pre>
		</div>

		<div class="panel panel2">
			<span class="legend">Instance</span>
			<pre><code class="language-javascript">const opening = new Animation({ delay: 300 }); // easing is optional
opening.delay = "fast"; // String is a valid type
opening.delay = null;</code>
<code class="language-none exception">TypeError: expecting delay to be Number or String, got null</code>
<code class="language-javascript">opening.easing = true; // Boolean is a valid type
opening.easing = 1;</code>
<code class="language-none exception">TypeError: expecting easing to be Boolean or String or undefined, got Number 1</code></pre>
		</div>
	</section>

	<hr>

	<section id="doc-value-checking" class="grid doc-code">
		<div class="doc">
			<h2>Value checking and enumerations</h2>
			<p>Instead of types, values can be specified for model properties. The property value must match the model one. If a regular expression is passed, the value must match it. Use brackets notation for value enumerations. Note that values and types can be mixed for one property.</p>
		</div>

		<div class="panel">
			<span class="legend">Model</span>
			<pre><code class="language-javascript">const Shirt = new ObjectModel({
	// the only acceptable value is "clothes"
	category: "clothes",

	// valid values: 38, 42, "S", "M", "L", "XL", "XXL"...
	size: [Number, "M", /^X{0,2}[SL]$/],

	// valid values: "black", "#FF0000", undefined...
	color: ["black","white", new RegExp("^#([A-F0-9]{6})$"), undefined]
});</code></pre>
		</div>
	</section>

	<hr>

	<section id="doc-null-safe" class="grid doc-code-code">
		<div class="doc">
			<h2>Null-safe object traversal</h2>
			<p>When you want to traverse nested objects, you always have to worry about the null pointer exception. Some languages such as Groovy have a safe navigation operator represented by <code>?.</code> to safely navigate through potential null references. In JavaScript, there is no such solution so you have to manually check for <code>undefined/null</code> values at each level of the object. But within an ObjectModel, declared properties are null-safe for traversal: every instance complete its structure with undefined properties according to the model definition.</p>
		</div>

		<div class="panel panel1">
			<span class="legend">Model and instanciation</span>
			<pre><code class="language-javascript">const Config = new ObjectModel({
	local: {
		time: {
			format: ["12h","24h", undefined]
		}
	}
});

const config = { local: undefined }; // object duck typed
const model_config = Config(config); // object model</code></pre>
		</div>

		<div class="panel panel2">
			<span class="legend">Traversal</span>
			<pre><code class="language-javascript">if(config.local.time.format === "12h"){ hour %= 12; }</code>
<code class="language-none exception">TypeError: Cannot read property 'time' of undefined</code>

<code class="language-javascript">// so to prevent this exception, we have to check this way:
if(config != null
&& config.local != null
&& config.local.time != null
&& config.local.time.format === "12h"){
	hour %= 12;
}

// with object models, no worries :)
if(model_config.local.time.format === "12h"){ hour %= 12; }
// model_config.local.time.format returns undefined</code></pre>
		</div>
	</section>

	<hr>

	<section id="doc-default-values" class="grid doc-code-code">
		<div class="doc">
			<h2>Default values assignment</h2>
			<p>You can set a default value for any model with <code>model.defaultTo(value)</code>. This default value will be used if the argument passed to the model constructor is undefined.</p>
		</div>

		<div class="panel panel1">
			<span class="legend">Model</span>
			<pre><code class="language-javascript">let N = BasicModel(Number).defaultTo(1)</code></pre>
		</div>

		<div class="panel panel2">
			<span class="legend">Instance</span>
			<pre><code class="language-javascript">N(5) + N() === 6</code></pre>
		</div>

		<div class="doc">
			<p>To specify default values for some properties of your object models, put them in the model prototype. You can also use the <code>defaults</code> method as a shorthand for setting all the default values at once. If these are not defined at object instanciation, their default value will be assigned.</p>
		</div>

		<div class="panel panel1">
			<span class="legend">Model</span>
			<pre><code class="language-javascript">const FileInfo = ObjectModel({
	name: String,
	size: [Number],
	creationDate: [Date],
	writable: Boolean
}).defaults({
	name: "Untitled file",
	size: 0,
	writable: true
});</code></pre>
		</div>

		<div class="panel panel2">
			<span class="legend">Instance</span>
			<pre><code class="language-javascript">let file = new FileInfo({ writable: false });</code>
<code class="language-javascript">file.name; // name is mandatory but a default value was passed</code>
<code class="language-none log">"Untitled file"</code>
<code class="language-javascript">file.size; // size is optional, but the default value still applies</code>
<code class="language-none log">0</code>
<code class="language-javascript">file.creationDate; // no default value was passed for this property</code>
<code class="language-none log">undefined</code>
<code class="language-javascript">file.writable; // passed value overrides default value</code>
<code class="language-none log">false</code>
<code class="language-javascript">Object.keys(file);</code>
<code class="language-none log">["name","size","creationDate","writable"]</code></pre>
		</div>
	</section>

	<hr>

	<section id="doc-composition" class="grid doc-code-code">
		<div class="doc">
			<h2>Composition with models as types</h2>
			<p>Models declared can also be used for type checking, so you can compose structures of models. Note that the property values do not necessarily need to be model instances to be considered valid: only the definition of the associated model must be respected. This is called <a href="http://en.wikipedia.org/wiki/Duck_typing" target="_blank">duck typing</a>, which can be summarized as <i>"If it looks like a duck and quacks like a duck, then it's a duck"</i>.</p>
			<p>When a model definition is recognized, the value is automatically replaced by an instance of the corresponding model. This naive approach is very time saving and allows you, for example, to parse composed models from JSON in one step. If there is somehow an ambiguity (such as two possible valid models within an union type), the value is kept unchanged and a warning console message will inform you how to solve this ambiguity.</p>
		</div>

		<div class="panel panel1">
			<span class="legend">Model</span>
			<pre><code class="language-javascript">const Person = ObjectModel({
	name: String,
	age: [Number]
});

const Lovers = ObjectModel({
	husband: Person,
	wife: Person
});</code></pre>
		</div>

		<div class="panel panel2">
			<span class="legend">Instance</span>
			<pre><code class="language-javascript">const joe = { name: "Joe", age: 42 };
const ann = new Person({
	name: joe.name + "'s wife",
	age: joe.age - 5
});

const couple = Lovers({
   husband: joe,  // object duck typed
   wife: ann // object model
});

couple.husband instanceof Person === true // object has been casted to Person</code></pre>
		</div>
	</section>

	<hr>

	<section id="doc-extensions" class="grid doc-code-code">
		<div class="doc">
			<h2>Inheritance by extension</h2>
			<p>Extensions create new models based on existing model definitions. You can declare new properties or override previous ones. Therefore, it is an easy way to reproduce subtyping and class inheritance.</p>
		</div>

		<div class="panel panel1">
			<span class="legend">Model</span>
			<pre><code class="language-javascript">const Person = ObjectModel({
	name: String,
	female: Boolean
});

const Mother = Person.extend({
	female: true,
	child: Person
});</code></pre>
		</div>

		<div class="panel panel2">
			<span class="legend">Instance</span>
			<pre><code class="language-javascript">let joe = new Person({ name: "Joe", female: false });
let ann = new Person({ name: "Ann", female: true });
let joanna = new Person({ name: "Joanna", female: true });

ann = new Mother({ name: "Ann", female: true, child: joanna })
ann instanceof Mother && ann instanceof Person // true</code>

<code class="language-javascript">joe = Mother(joe); // try to cast joe to Mother model</code>
<code class="language-none exception">TypeError: expecting female to be true, got Boolean false
expecting child to be {
	name: String,
	female: Boolean
}, got undefined</code></pre>
		</div>

		<div class="doc">
			<h3>With ES6 classes</h3>
			<p>Extended models inherit the parent's prototype chain, so you can easily combine it with class inheritance. Just make sure to respect the <a href="https://en.wikipedia.org/wiki/Liskov_substitution_principle" target="_blank">Liskov substitution principle</a> when you extend a type definition.</p>
		</div>

		<div class="panel panel1">
			<span class="legend">Model</span>
			<pre><code class="language-javascript">class Person extends ObjectModel({ name: String, female: Boolean }){
	constructor({ name, female }){
		if(!female) name = `Mr ${name}`
		super({ name, female })
	}
}

class Mother extends Person.extend({ female: true, child: Person }){
	constructor({ name, female, child }){
		super({ name: `Mrs ${name}`, female, child })
	}
}</code></pre>
		</div>

		<div class="panel panel2">
			<span class="legend">Instance</span>
			<pre><code class="language-javascript">let joe = new Person({ name: "Joe", female: false })
let joanna = new Person({ name: "Joanna", female: true })
let ann = new Mother({ name: "Ann", female: true, child: joanna })</code>

<code class="language-javascript">joe.name</code>
<code class="language-none log">Mr Joe</code>
<code class="language-javascript">ann.name</code>
<code class="language-none log">Mrs Ann</code></pre>
		</div>

	</section>

	<hr>

	<section id="doc-multiple-inheritance" class="grid doc-code-code">
		<div class="doc">
			<h2>Multiple inheritance</h2>
			<p>But it goes further: you can do multiple inheritance and mix any number of parent models definitions and assertions. If some properties have the same name, those of the last object overrides the others.</p>
		</div>

		<div class="panel panel1">
			<span class="legend">Model</span>
			<pre><code class="language-javascript">const Client = Person.extend(User, Order, { store: String });

Client.prototype.sendConfirmationMail = function(){
	return this.email + ": Dear " + this.name
	+ ", thank you for ordering "
	+ this.product.quantity + " " + this.product.name
	+ " on " + this.store;
};

Object.keys(Client.definition);</code>
<code class="language-none log">["name", "female", "email", "product", "orderDate", "store"]</code></pre>
		</div>

		<div class="panel panel2">
			<span class="legend">Instance</span>
			<pre><code class="language-javascript">const joe = new Client({
	name: "Joe",
	female: false,
	email: "joe@email.net",
	product: { name: "diapers", quantity: 100 },
	orderDate: new Date(),
	store: "daddy.net"
});

joe.sendConfirmationMail();</code>
<code class="language-none log">joe@email.net: Dear Joe, thank you for ordering 100 diapers on daddy.net</code></pre>
		</div>
	</section>

	<hr>

	<section id="doc-assertions" class="grid doc-code-code">
		<div class="doc">
			<h2>Assertions for custom validation tests</h2>
			<p>You can add to your models any number of assertions that are custom test functions applied on model instances. All assertions are called every time the model is changed, and must all return <code>true</code> to validate. Exceptions thrown in assertions are catched and considered as assertion failures.</p>
			<p>For example, we can get an Integer model by adding <code>Number.isInteger</code> as an assertion to a basic <code>Number</code> model.</p>
			<p>Assertions are inherited from the model prototype, so you can add global assertions on all models by setting them in <code>Model.prototype</code>. The second argument of the <code>assert</code> method is an optional message shown when assertion fails. It can be a String or a function returning a String.</p>
		</div>

		<div class="panel panel1">
			<span class="legend">Model</span>
			<pre><code class="language-javascript">const PositiveInteger = BasicModel(Number)
	.assert(Number.isInteger)
	.assert(n => n >= 0, "should be greater or equal to zero")

function isPrime(n) {
	for (let i=2, m=Math.sqrt(n); i <= m ; i++){
		if(n%i === 0) return false;
	}
	return n > 1;
}

const PrimeNumber = PositiveInteger.extend().assert(isPrime);
// extend to not add isPrime assertion to the Integer model
</code></pre>
		</div>

		<div class="panel panel2">
			<span class="legend">Instance</span>
			<pre><code class="language-javascript">PositiveInteger(-1);</code>
<code class="language-none exception">TypeError: assertion should be greater or equal to zero returned false for value -1</code>

<code class="language-javascript">PositiveInteger(Math.sqrt(2));</code>
<code class="language-none exception">TypeError: assertion isInteger returned false for value 1.4142135623730951</code>

<code class="language-javascript">PrimeNumber(83);</code>
<code class="language-none log">83</code>

<code class="language-javascript">PrimeNumber(87);</code>
<code class="language-none exception">TypeError: assertion isPrime returned false for value 87</code></pre>
		</div>
	</section>

	<hr>

	<section id="doc-private-and-constants" class="grid doc-code-code">
		<div class="doc">
			<h2>Private and constant properties</h2>
			<p>Some variable naming conventions are commonly used in JavaScript. For example, a leading underscore is used to specify a <i>_private</i> variable which should not be used outside its class methods. Also, constants are often in <i>ALL_CAPS</i>. Model definitions follow these conventions by making <i>_underscored</i> properties not enumerable and <i>CAPITALIZED</i> properties not writable.</p>
			<p>You can modify or remove these conventions by overriding the <code>conventionForPrivate</code> and <code>conventionForConstant</code> methods in your model or globally in <code>Model.prototype</code>.</p>
		</div>

		<div class="panel panel1">
			<span class="legend">Model</span>
			<pre><code class="language-javascript">const Circle = ObjectModel({
	radius: Number, // public
	_diameter: [Number], // private
	UNIT: ["px","cm","mm"], // constant
	_ID: [Number], // private and constant
});</code></pre>
		</div>

		<div class="panel panel2">
			<span class="legend">Instance</span>
			<pre><code class="language-javascript">let c = new Circle({ radius: 120, UNIT: "px", _ID: 1 });
c.radius = 100;
c.UNIT = "cm";</code>
<code class="language-none exception">TypeError: cannot redefine constant UNIT</code>
<code class="language-javascript">Object.keys(c); // private variables are not enumerated</code>
<code class="language-none log">["radius", "UNIT"]</code></pre>
		</div>
	</section>
	<hr>

	<section id="doc-array-model" class="grid doc-code-code">
		<div class="doc">
			<h2>Array models</h2>
			<p>Array models validate the array elements types. All the validation options for object models are also available for array model elements: type/value checking, optional properties, union types, enumerations, assertions...</p>
		</div>

		<div class="panel panel1">
			<span class="legend">Model</span>
			<pre><code class="language-javascript">const Family = ObjectModel({
	father: Father,
	mother: Mother,
	children: ArrayModel(Person), // array of Persons
	grandparents: [ArrayModel([Mother, Father])]
	            // optional array of Mothers or Fathers
});</code></pre>
		</div>

		<div class="panel panel2">
			<span class="legend">Instance</span>
			<pre><code class="language-javascript">const joefamily = new Family({
	father: joe,
	mother: ann,
	children: [joanna, "dog"]
});</code>
<code class="language-none exception">TypeError: expecting Array[1] to be { name: String, female: Boolean }, got String "dog"</code>
</pre>
		</div>

		<div class="doc">
			<p>The validation is done on initial array elements passed to the model, then on new elements added or modified afterwards.</p>
			<p class="note">Note that for <a href="http://kangax.github.io/compat-table/es6/#test-Proxy" target="_blank">browsers which do not support ES6 proxies</a>, if you expand the array by storing an element at an index greater than the current array length (which is commonly considered as a bad practice), the new element and model assertions may not be validated. Use a mutator method like <code>push</code> or <code>splice</code> instead.</p>
		</div>

		<div class="panel panel1">
<pre><code class="language-javascript">const Cards = ArrayModel([Number, "J","Q","K"]);
const Hand = Cards.extend("Joker").assert(cards => cards.length === 2, "should have two cards");
// Hand is an array of 2 Numbers, J, Q, K or Joker</code></pre>
		</div>

		<div class="panel panel2">
<pre><code class="language-javascript">const myHand = Hand( [7, "Joker"] );
myHand[2] = "K"; // may not trigger validation this way
myHand.push("K"); // use this instead</code>
<code class="language-none exception">TypeError: assertion "should have two cards" returned false for value [7, "Joker", "K"]</code></pre>
		</div>
	</section>

	<hr>

	<section id="doc-function-model" class="grid doc-code-code">
		<div class="doc">
			<h2>Function models</h2>
			<p>Function models provide validation on input (arguments) and output (return value). All the validation options for Object models are also available for Function models. The arguments passed to <code>FunctionModel</code> are the types of the arguments the function will receive, and the <code> return</code> method is used to specify the type of the function return value.</p>
		</div>

		<div class="panel panel1">
<pre><code class="language-javascript">const Operand = BasicModel(Number).assert(Number.isFinite);
const Operator = BasicModel(["+","-","*","/"])

const Calculator = FunctionModel(Operand, Operator, Operand).return(Operand);

const calc = new Calculator((a, operator, b) => eval(a + operator + b));
</code></pre>
		</div>

		<div class="panel panel2">
<pre><code class="language-javascript">calc(3, "+", 1);</code>
<code class="language-none log">4</code>
<code class="language-javascript">calc(6, "*", null);</code>
<code class="language-none exception">TypeError: expecting arguments[2] to be Number, got null</code>
<code class="language-javascript">calc(1, "/", 0);</code>
<code class="language-none exception">TypeError: assertion "isFinite" returned false for value Infinity</code></pre>
		</div>

		<div class="doc">
			<p>In classical JavaScript OOP programming, methods are declared in the constructor's <code>prototype</code>. You can do the same with instances of function models. Another option is to provide a default implementation in the model definition by using the <code>defaults</code> method. <a	href="#doc-default-values">See the 'Default values' section</a>. The difference is that all the properties in the model definition are required for an object to be considered suitable for the model.	In the following example, an object must have a function <code>sayMyName</code> to be valid as a Person, while the function <code>greet</code> is not mandatory.</p>
		</div>

		<div class="panel panel1">
			<span class="legend">Model</span>
			<pre><code class="language-javascript">const Person = ObjectModel({
	name: String,
	// function without arguments returning a String
	sayMyName: FunctionModel().return(String)
}).defaults({
	sayMyName: function(){ return "my name is " + this.name }
})

// takes one Person as argument, returns a String
Person.prototype.greet = FunctionModel(Person).return(String)(
	function(otherguy){ return "Hello "+ otherguy.name + ", " + this.sayMyName() }
)</code></pre>
		</div>

		<div class="panel panel2">
			<span class="legend">Instance</span>
			<pre><code class="language-javascript">const joe = new Person({ name: "Joe" });

joe.sayMyName();</code>
<code class="language-none log">my name is Joe</code>
<code class="language-javascript">joe.greet({ name: "Ann", greet: "hi ?" });</code>
<code class="language-none log">Hello Ann, my name is Joe</code>
<code class="language-javascript">joe.greet({ name: "dog", sayMyName: "woof !" });</code>
<code class="language-none exception">TypeError: expecting arguments[0].sayMyName to be "Function", got String "woof !"</code></pre>
		</div>

	</section>

	<hr>

	<section id="doc-custom-collectors" class="grid doc-code-code">
		<h2>Custom error collectors</h2>
		<div class="doc">
			<p>By default, validation errors are collected every time a model instance is created or modified, and thrown as <code>TypeError</code> exceptions with a message describing all the errors found. It it possible to change this behaviour and add your own error collectors. For example, you may want to notify the user that an error occurred, or send the information to your server for error tracking on production.</p>
		</div>
		<div class="doc">
			<p>Error collectors are callback functions called with an array of all the errors collected during the last model inspection. Every error is an object with these properties:</p>
			<ul>
				<li><code>message</code>: a message describing the error</li>
				<li><code>expected</code>: the expected type definition or assertion/li>
				<li><code>received</code>: the received value, to compare to the expected</li>
				<li><code>path</code>: the path where the error occurred in an object model definition</li>
			</ul>
		</div>

		<div class="doc">
			<h3>Global error collector</h3>
			<p>This is how you define an error collector globally for all models.</p>
		</div>

		<div class="panel panel1">
			<pre><code class="language-javascript">Model.prototype.errorCollector = function(errors){
	console.log("Global error collector caught these errors:");
	errors.forEach(error => { console.dir(error) });
};

const Student = ObjectModel({
	name: String,
	course: [ "math","english","history" ],
	grade: Number
}).assert(student => student.grade >= 60,
          "should at least get 60 to validate semester")

new Student({ name: "Joanna", course: "sleep", grade: 0 });</code></pre>
		</div>

		<div class="panel panel2">
			<pre><code class="language-none log">Global error collector caught these errors:
{
	message: 'expecting course to be "math" or "english" or "history", got String "sleep"'
	path: "course"
	expected: ["math","english","history"]
	received: "sleep"
}
{
	message: "assertion should at least get 60 to validate semester returned false for value { name: "Joanna", course: "sleep", grade: 0 }",
	path: null,
	expected: student => student.grade >= 60,
	received: { name: "Joanna", course: "sleep", grade: 0 }
}</code></pre>
		</div>

		<div class="doc">
			<h3>Model error collector</h3>
			<p>This is how you define an error collector specifically by model</p>
		</div>

		<div class="panel panel1">
			<pre><code class="language-javascript">Student.errorCollector = function(errors){
	console.log("Student model error collector caught these errors:");
	errors.forEach(error => { console.dir(error) });
};

new Student({ name: "Joanna", course: "math", grade: 50 });</code></pre>
		</div>

		<div class="panel panel2">
			<pre><code class="language-none log">Student model collector caught these errors:
{
	message: "assertion should at least get 60 to validate semester returned false for value { name: "Joanna", course: "math", grade: 50 }",
	path: null,
	expected: student => student.grade >= 60,
	received: { name: "Joanna", course: "math", grade: 50 }
}</code></pre>
		</div>

		<div class="doc">
			<h3>Single-use error collector</h3>
			<p>And this is how you define an error collector to be used only once with <code>validate(obj, myErrorCollector)</code></p>
		</div>

		<div class="panel panel1">
			<pre><code class="language-javascript">Student.validate({
	name: "Joanna",
	course: "cheating",
	grade: 90
}, function(errors){
	console.log("This specific error collector caught these errors:");
	errors.forEach(error => { console.dir(error) });
});</code></pre>
		</div>

		<div class="panel panel2">
			<pre><code class="language-none log">This specific error collector caught these errors:
{
	message: 'expecting course to be "math" or "english" or "history", got String "cheating"'
	path: "course"
	expected: ["math","english","history","science"]
	received: "cheating"
}</code></pre>
		</div>

	</section>

	<hr>

	<section id="api">
		<h2>Full API</h2>
		<h3>Imported from objectmodel root scope</h3>
		<dl>
			<dt><a href="#doc-basic-model">BasicModel</a> <code>BasicModel(definition)</code></dt>
			<dd>Constructor for basic models</dd>

			<dt><a href="#doc-object-model">ObjectModel</a> <code>ObjectModel(definition)</code></dt>
			<dd>Constructor for object models</dd>

			<dt><a href="#doc-array-model">ArrayModel</a> <code>ArrayModel(itemDefinition)</code></dt>
			<dd>Constructor for array models</dd>

			<dt><a href="#doc-function-model">FunctionModel</a> <code>FunctionModel(definitionArgument1,
				definitionArgument2, ...)</code></dt>
			<dd>Constructor for function models</dd>

			<dt><a href="#doc-function-model">MapModel</a> <code>MapModel(keyDefinition, valueDefinition)</code></dt>
			<dd>Constructor for map models</dd>

			<dt><a href="#doc-function-model">SetModel</a> <code>SetModel(itemDefinition)</code></dt>
			<dd>Constructor for set models</dd>

		</dl>
		<h3>Model methods and properties</h3>
		<dl>
			<dt>definition <code>model.definition</code></dt>
			<dd>Returns the model definition</dd>

			<dt>assertions <code>model.assertions</code></dt>
			<dd>Returns the list of model assertions</dd>

			<dt>default <code>model.default</code></dt>
			<dd>Returns the default value if defined</dd>

			<dt>errorCollector <code>model.errorCollector = function(errors){ ... }</code></dt>
			<dd>Function called when validation errors are detected</dd>

			<dt><a href="#doc-extensions">extend</a> <code>model.extend(...otherDefinitions)</code></dt>
			<dd>Returns a new model based on the initial model definition merged with other definitions passed. Assertions are preserved too.</dd>

			<dt><a href="#doc-assertions">assert</a> <code>model.assert(assertion, [description])</code></dt>
			<dd>Add a test function to the model that must return <code>true</code> to validate the instance.</dd>

			<dt><a href="#doc-default-values">defaultTo</a> <code>model.defaultTo(defaultValue)</code></dt>
			<dd>Shorthand to set the default value of the model</dd>

			<dt><a href="#doc-composition">test</a> <code>model.test(value)</code></dt>
			<dd>Returns <code>true</code> if the value passed validates the model definition. Works with <a href="#doc-composition">duck typing</a>.</dd>

			<dt>validate <code>model.validate(instance, [errorCollector])</code></dt>
			<dd>Manually triggers the validation of a model instance over its definition. It is automatically done whenever an instance property changes.
				<br>
				Note that contrary to the <code>test</code> method, the object is not cast to its suitable model (a.k.a <a href="#doc-composition">duck typing</a>) before being validated.
			</dd>

			<dt><a href="#doc-private-and-constants">conventionForConstant</a> <code>function(variableName)</code></dt>
			<dd>Internal function used to identify a constant property based on naming convention. You can override it to suit your needs.</dd>

			<dt><a href="#doc-private-and-constants">conventionForPrivate</a> <code>function(variableName)</code></dt>
			<dd>Internal function used to identify a non-enumerable property based on naming convention. You can override it to suit your needs.</dd>

		</dl>
		<h3>Object models</h3>
		<dl>
			<dt>defaults <code>objectModel.defaults(defaultValuesObject)</code></dt>
			<dd>Merge the object passed within the model prototype to set defaults values for some model properties.</dd>
		</dl>
		<h3>Function models</h3>
		<dl>
			<dt>return <code>functionModel.return(returnValueDefinition)</code></dt>
			<dd>Set the definition of the return value. Each call to the function must return a validated value, otherwise an exception will be raised.</dd>
		</dl>
	</section>

	<hr>

	<section id="common-models">
		<h2>Commonly used models</h2>
		<p>Here are some models that you may find useful. <strong>These are not included in the library</strong>, so pick what you need or <a href="examples/common.js">get them all from here</a></p>

		<pre><code class="language-javascript" data-source="examples/common.js"></code></pre>
	</section>
	<hr>

	<section id="common-questions">
		<h2>Common questions</h2>

		<details>
			<summary id="browser-support">Which browsers are supported ?</summary>
			<p>This library is <a href="test/" target="_blank">unit tested</a> against these browsers, depending of the version of Object Model:</p>
			<dl>
				<dt><a href="docs/v1">v1.x</a></dt>
				<dd>Chrome 29+, Firefox 24+, Edge, Internet Explorer 9+, Opera 20+, Safari 5.1+</dd>
				<dt><a href="docs/v2">v2.x</a></dt>
				<dd>Support for IE < 11 had to be dropped in v2 because it required many hacks and was holding back other browsers.</dd>
				<dt>v3.x</dt>
				<dd>ObjectModel v3 is built around ES6 Proxies, so requires modern browsers : Edge 14+, Firefox 47+, Chrome 50+, Safari 10+. It also works on Node 6.0+.</dd>
			</dl>
		</details>

		<details>
			<summary>What is the impact on performance ?</summary>
			<p>To get dynamic type validation, Object models have to override properties setters so that each assignment passes through a function that acts as a proxy. This has a cost, especially on old browsers. Therefore, it is not advisable to use object models in performance-critical parts of your applications. In particular, Array models and circular references in models have the most impact on performance. But in	general, the loss of time does not exceed a few milliseconds and is quite negligible.</p>
		</details>

		<details>
			<summary>How do I declare a constructor function to be called on instanciation before validating my model ?</summary>
			<div class="grid doc-code">
				<div class="doc">
					<p>The recommended way is to use a factory function to instanciate your models. You can declare as many different factories as needed, which makes this pattern both simple and flexible.</p>
				</div>
				<div class="panel">
					<pre><code class="language-javascript">const User = ObjectModel({
    firstName: String,
    lastName: String,
    fullName: String
});

User.create = function(properties){
    properties.fullName = properties.firstName + " " + properties.lastName;
    return new User(properties);
};

const joe = User.create({ firstName: "Joe", lastName: "Dalton" });</code></pre>
				</div>
			</div>
		</details>

		<details>
			<summary>How can I get the model from an instance ?</summary>
			<div class="grid doc-code">
				<div class="doc">
					<p>With the <code>constructor</code> property. If this property is used in your model, you can also	retrieve it with <code>Object.getPrototypeOf(instance).constructor</code>. This is useful for retrieving the type of a property for example.</p>
				</div>
				<div class="panel">
					<pre><code class="language-javascript">const User = ObjectModel({ name: String }),
	joe = User({ name: "Joe" });

const modelOfJoe = joe.constructor // or Object.getPrototypeOf(joe).constructor;
// modelOfJoe === User
// modelOfJoe.definition.name === String</code></pre>
				</div>
			</div>
		</details>

		<details>
			<summary>How should I deal with circular references in my model definitions ?</summary>
			<div class="grid doc-code">
				<div class="doc">
					<p>You can't refer to a model or instance that is not yet defined, so you have to update the definition afterwards:</p>
				</div>
				<div class="panel">
					<pre><code class="language-javascript">const Honey = ObjectModel({
   sweetie: undefined // Sweetie is not yet defined
});

const Sweetie = ObjectModel({
   honey: Honey
});

Honey.definition.sweetie = [Sweetie];

const joe = Honey({ sweetie: undefined }); // ann is not yet defined
const ann = Sweetie({ honey: joe });
joe.sweetie = ann;</code></pre>
				</div>
			</div>
		</details>

		<details>
			<summary>How can I serialize/deserialize objects while preserving type information ?</summary>
			<div class="grid doc-code-code">
				<div class="doc">
					<p>Serializing in JSON necessarily implies that you lose the type information, except if you store it manually with your data, then retrieve it with a custom parsing function. It is for the best to let you decide how you want to store the type information within your data.</p>
					<p>Here is a proposal of implementation using a simple <code>{ _value, _type }</code> wrapper:</p>
				</div>

				<div class="panel panel1">
					<span class="legend">Implementation</span>
					<pre><code class="language-javascript">Model.prototype.serialize = function(instance, models){
	const names = Object.keys(models);
	return JSON.stringify(instance, function(key, value){
		const modelName = names.find(name => value instanceof models[name]);
		if(modelName && key !== "_value"){
			return { _type: modelName, _value: value }
		}
		return value;
	}, '\t');
}

Model.prototype.parse = function(json, models){
	return JSON.parse(json, function(key, o){
		if(o && o._type in models){
			return new models[o._type](o._value);
		}
		return o;
	})
}</code></pre>
				</div>
				<div class="panel panel2">
					<span class="legend">Example</span>
					<pre><code class="language-javascript">const Type1 = ObjectModel({ content: String }).defaultTo({ content: 'Content 1' }),
      Type2 = ObjectModel({ content: String }).defaultTo({ content: 'Content 2' }),
	  Container = ObjectModel({ items: ArrayModel([Type1, Type2]) });

// List all your serializable models here
const serializableModels = { Container, Type1, Type2 };

let a = new Container({ items: [new Type1, new Type2] });

let json = Container.serialize(a, serializableModels);
console.log(json);

let b = Container.parse(json, serializableModels);
console.log(
	b instanceof Container,
	b.items[0] instanceof Type1,
	b.items[1] instanceof Type2
);</code></pre>
				</div>
			</div>
		</details>

	</section>

	<section>
		<h2>I have a question / suggestion / bug to report</h2>
		<p>Please check the documentation twice, then open an issue on the
			<a href="https://github.com/sylvainpolletvillard/ObjectModel/issues" target="_blank">Github repository</a>
		</p>
	</section>

	<section>
		<h2>Like what you see ? Share it with the world !</h2>

		<ul class="share-buttons">
			<li>
				<a href="https://www.facebook.com/sharer/sharer.php?u=http%3A%2F%2Fobjectmodel.js.org&t=ObjectModel%3A%20Model%20Definition%20and%20Runtime%20Type%20Checking%20for%20JavaScript"
				   title="Share on Facebook"
				   target="_blank"
				   onclick="window.open(this.href); return false;">
					<img src="docs/res/facebook.svg" width="48" height="48">
				</a>
			</li>
			<li>
				<a href="https://twitter.com/intent/tweet?source=http%3A%2F%2Fobjectmodel.js.org&text=ObjectModel%3A%20Model%20Definition%20and%20Runtime%20Type%20Checking%20for%20JavaScript%20-%20http%3A//objectmodel.js.org"
				   target="_blank"
				   title="Tweet"
				   onclick="window.open(this.href); return false;">
					<img src="docs/res/twitter.svg" width="48" height="48">
				</a>
			</li>
			<li>
				<a href="https://plus.google.com/share?url=http%3A%2F%2Fobjectmodel.js.org"
				   target="_blank"
			       title="Share on Google+"
			       onclick="window.open(this.href); return false;">
					<img src="docs/res/googleplus.svg" width="48" height="48">
				</a>
			</li>
			<li>
				<a href="https://gitter.im/sylvainpolletvillard/ObjectModel?utm_source=website"
				   target="_blank"
			       title="Chat on Gitter">
					<img src="docs/res/gitter.svg" width="48" height="48">
				</a>
			</li>
		</ul>

	</section>

	<hr>
	<footer><a href="LICENSE">MIT licensed</a> - Sylvain Pollet-Villard</footer>
</div>

</body>
</html>
